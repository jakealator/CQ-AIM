% generateUSHat.m
% Created on: 02-17-2017 by JDR in Newark
% Last Modified: 02-20-2017
%
% Inputs: uiHat      - the Nx1 incident field corresponding to current
%                      wavenumber 
%         triAreas 
%         nearFieldDistances
% iElements, ...
    jElements, centroids, extraFarFieldElements, c, c0,
%         Ng         - Number of Cartesian grid points
%         N          - Number of FEM grid points
%         waveNumber - current wavenumber
%         P          - NxNg interpolation matrix
%
% Outputs: usHat - Nx1 vector containing the uSHat data for a fixed
%                  wavenumber. 
%
% Generates the scattered field corresponding to a wavenumber k, an index
% of refraction defined by c and the shape D, and an incident field ui.
% This is just a time harmonic scattered field. However, it is computed in
% the near field with a P0-Galerkin approximation to the Lippmann-Schwinger
% equation and in the far field with a FFT-based techinque, using
% delta-function 'basis functions' defined on a rectangular grid. 
%
% Algorithm: 1) Calculate near field based on previously-computed near
%               field grid. 
%            2) Compute RHS
%            3) Use CG to solve for US in D, using 1) and far field
%               computed during iterations
%            4) Find solution in exterior. 

function usHat = generateUSHat(uiHat,triAreas, nearFieldDistances, iElements, ...
    jElements, centroids, extraFarFieldElements, c, c0, Ng,N,waveNumber,P)

% First compute near field components 
[K,M] = assembleNearFieldMatrices(triAreas, nearFieldDistances, ...
    iElements, jElements, centroids, extraFarFieldElements, c,c0,waveNumber,N);

% All we need to do now is compute the rhs and then use conjugate gradient to
% solve (I+V)x = rhs. 
rhs = applyV(uiHat,K,Ng,N,fftG,P);
usHat = cgs(@(x)applyIPlusV(x,M,K,Ng,N,fftG,P),rhs);


end

% aFarX applies operator Afar to a vector x. Output is approximation to Ax
% evaluated back on finite element mesh through the interpolation matrix. 
function Ax = applyIPlusV(x,M,K,Ng,N,fftG,P)

Ax = M*x+applyV(x,K,Ng,N,fftG, P);



end